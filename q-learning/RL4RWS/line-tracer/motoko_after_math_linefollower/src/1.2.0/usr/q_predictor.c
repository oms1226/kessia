#include "q_predictor.h"
#include "../lib_usr/math.h"


const i16 predictor_models_init[Q_PREDICTOR_MODELS_COUNT][Q_PREDICTOR_MODEL_SIZE] =
{
  /*
  {989, 990,  993,  994,  996,  997,  999,  999,  998,  996,  986,  970,  957,  941,  927,  915},
  {754, 51,   630,  983,  157,  821,  136,  650,  164,  317,  466,  614,  415,  172,  149,  196},
  {445, 470,  492,  519,  544,  575,  622,  701,  806,  905,  976,  976,  874,  718,  522,  377},
  {157, 981,  626,  262,  968,  985,  463,  371,  89,   984,  626,  131,  307,  91,   634,  816},
  {580, 619,  660,  706,  756,  813,  869,  914,  944,  971,  997,  997,  997,  997,  989,  969},
  {506, 528,  538,  589,  642,  655,  671,  641,  552,  439,  326,  204,  148,  100,  81,   101},
  {83,  65,   50,   33,   35,   38,   43,   48,   53,   58,   63,   68,   74,   80,   86,   92},
  {705, 670,  176,  698,  145,  271,  694,  103,  749,  468,  266,  972,  336,  500,  17,   216},
  {898, 929,  947,  956,  963,  958,  863,  758,  642,  514,  454,  430,  403,  378,  353,  328},
  {255, 230,  199,  190,  166,  140,  113,  86,   77,   68,   61,   53,   42,   31,   35,   40},
  {422, 105,  711,  162,  15,   127,  217,  996,  133,  152,  777,  759,  44,   849,  144,  798},
  {466, 476,  482,  489,  497,  507,  514,  533,  560,  589,  624,  699,  776,  849,  906,  914},
  {696, 681,  639,  543,  439,  312,  228,  183,  146,  109,  85,   62,   43,   46,   49,   58},
  {336, 422,  321,  452,  360,  237,  171,  457,  551,  937,  985,  855,  560,  335,  425,  547},
  {630, 602,  573,  540,  504,  463,  476,  490,  492,  494,  494,  495,  497,  498,  511,  524},
  {225, 219,  225,  231,  236,  237,  246,  256,  274,  298,  341,  387,  429,  473,  522,  532}
  */

/*
{328, 342, 357, 373, 390, 408, 424, 441, 460, 480, 501, 509, 516, 521, 524, 530},
{754, 51, 630, 983, 157, 821, 136, 650, 164, 317, 466, 614, 415, 172, 149, 196},
{748, 689, 616, 531, 522, 505, 478, 435, 389, 342, 290, 271, 251, 232, 231, 230},
{157, 981, 626, 262, 968, 985, 463, 371, 89, 984, 626, 131, 307, 91, 634, 816},
{588, 629, 679, 728, 781, 838, 888, 924, 947, 972, 999, 999, 999, 999, 990, 979},
{972, 978, 979, 985, 935, 835, 700, 563, 471, 436, 403, 365, 337, 308, 283, 281},
{168, 181, 194, 209, 225, 242, 243, 246, 251, 255, 260, 267, 274, 281, 289, 299},
{705, 670, 176, 698, 145, 271, 694, 103, 749, 468, 266, 972, 336, 500, 17, 216},
{452, 488, 538, 572, 671, 792, 889, 921, 961, 971, 890, 823, 721, 618, 487, 390},
{456, 434, 409, 385, 342, 299, 251, 223, 201, 187, 167, 148, 130, 111, 108, 112},
{422, 105, 711, 162, 15, 127, 217, 996, 133, 152, 777, 759, 44, 849, 144, 798},
{511, 567, 631, 714, 740, 827, 913, 898, 768, 620, 557, 459, 335, 204, 153, 131},
{71, 58, 51, 44, 34, 23, 19, 15, 11, 16, 27, 39, 53, 68, 87, 107},
{116, 99, 76, 49, 56, 73, 103, 134, 175, 211, 239, 252, 290, 331, 348, 354},
{976, 998, 999, 999, 998, 998, 996, 995, 966, 908, 844, 767, 682, 586, 514, 438},
{333, 337, 345, 365, 384, 407, 447, 506, 581, 664, 742, 819, 877, 936, 995, 990}
*/

/*
{340, 246, 207, 163, 114, 83, 58, 38, 17, 17, 22, 37, 56, 76, 98, 123},
{754, 51, 630, 983, 157, 821, 136, 650, 164, 317, 466, 614, 415, 172, 149, 196},
{840, 883, 919, 920, 905, 863, 766, 642, 571, 473, 388, 342, 317, 284, 264, 241},
{157, 981, 626, 262, 968, 985, 463, 371, 89, 984, 626, 131, 307, 91, 634, 816},
{403, 410, 448, 506, 607, 721, 812, 884, 942, 922, 900, 813, 661, 504, 434, 383},
{261, 260, 260, 259, 259, 259, 264, 279, 302, 328, 355, 384, 416, 450, 466, 477},
{365, 380, 397, 415, 434, 454, 476, 478, 479, 480, 481, 482, 483, 485, 485, 486},
{705, 670, 176, 698, 145, 271, 694, 103, 749, 468, 266, 972, 336, 500, 17, 216},
{759, 758, 687, 622, 554, 477, 417, 370, 313, 253, 212, 177, 140, 118, 119, 122},
{813, 886, 925, 990, 999, 999, 994, 988, 967, 937, 905, 813, 785, 760, 717, 692},
{422, 105, 711, 162, 15, 127, 217, 996, 133, 152, 777, 759, 44, 849, 144, 798},
{512, 531, 590, 631, 584, 524, 526, 495, 427, 412, 360, 313, 257, 248, 246, 249},
{449, 478, 518, 539, 586, 639, 718, 807, 890, 948, 971, 999, 996, 961, 903, 818},
{402, 373, 342, 319, 292, 274, 250, 224, 226, 229, 233, 238, 243, 249, 263, 277},
{118, 119, 121, 125, 132, 141, 155, 169, 184, 200, 219, 220, 221, 220, 221, 221},
{396, 398, 399, 410, 423, 442, 465, 493, 521, 569, 635, 721, 826, 903, 950, 936},
*/

{374, 409, 448, 466, 497, 525, 531, 538, 559, 582, 588, 593, 546, 494, 492, 454},
{754, 51, 630, 983, 157, 821, 136, 650, 164, 317, 466, 614, 415, 172, 149, 196},
{235, 235, 246, 260, 267, 282, 307, 333, 364, 393, 426, 446, 471, 499, 507, 517},
{157, 981, 626, 262, 968, 985, 463, 371, 89, 984, 626, 131, 307, 91, 634, 816},
{280, 256, 226, 197, 171, 201, 234, 239, 245, 252, 256, 268, 278, 289, 299, 309},
{599, 606, 614, 622, 632, 643, 654, 667, 680, 678, 675, 671, 667, 662, 657, 651},
{899, 946, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999, 999},
{708, 611, 212, 636, 163, 286, 629, 150, 720, 516, 353, 977, 418, 551, 16, 177},
{867, 910, 953, 999, 949, 872, 784, 693, 591, 481, 461, 470, 482, 480, 475, 468},
{425, 390, 351, 310, 266, 233, 220, 208, 191, 171, 141, 107, 95, 94, 92, 129},
{422, 105, 711, 162, 15, 127, 217, 996, 133, 152, 777, 759, 44, 849, 144, 798},
{434, 465, 492, 504, 531, 586, 648, 748, 827, 926, 961, 917, 832, 717, 590, 507},
{558, 601, 653, 703, 751, 792, 838, 798, 696, 590, 471, 402, 322, 239, 198, 209},
{264, 239, 217, 192, 165, 129, 98, 91, 107, 125, 166, 213, 232, 246, 278, 309},
{474, 486, 503, 556, 615, 664, 714, 749, 790, 827, 909, 999, 999, 999, 999, 999},
{618, 605, 588, 587, 588, 510, 419, 388, 352, 315, 274, 230, 236, 243, 238, 232},

};

i16 predictor_output_init[Q_PREDICTOR_MODELS_COUNT] =
{
  700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700, 700
};

i16 predictor_q_init[Q_PREDICTOR_MODELS_COUNT] =
{
  1878, 0, 989, 0, 1333,  761, 2302, 0, 2149, 1676, 0, 2631, 2413, 2382, 739, 1605
};

void q_predictor_init()
{
  u32 i, j;

  g_q_predictor.state = 0;
  g_q_predictor.prev_state = 0;


  for (i = 0; i < Q_PREDICTOR_MODEL_SIZE; i++)
    g_q_predictor.input[i] = 0.0;

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
    for (i = 0; i < Q_PREDICTOR_MODEL_SIZE; i++)
      g_q_predictor.models[j][i] = predictor_models_init[j][i]/1000.0; /* (m_rnd()%10000)/10000.0; */

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
    g_q_predictor.output[j] = predictor_output_init[j]/1000.0;

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
    g_q_predictor.q[j] = predictor_q_init[j]/1000.0;
}

float q_predictor_process(float input, float reward)
{
  u32 i, j;

  /*add new sample into fifo front*/
  for (i = (Q_PREDICTOR_MODEL_SIZE-1); i != 0; i--)
    g_q_predictor.input[i] = g_q_predictor.input[i-1];
  g_q_predictor.input[i] = m_abs(input);

  float dist_min = 10.0*Q_PREDICTOR_MODEL_SIZE;
  u32 dist_min_idx = 0;

  /*look for nearest model to current fifo state*/
  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
  {
    float dist = 0.0;
    for (i = 0; i < Q_PREDICTOR_MODEL_SIZE; i++)
      dist+= m_abs(g_q_predictor.input[i] - g_q_predictor.models[j][i]);

    if (dist < dist_min)
    {
      dist_min = dist;
      dist_min_idx = j;
    }
  }

  /*learn nearest model*/
  float learning_rate = 0.9;
  for (i = 0; i < Q_PREDICTOR_MODEL_SIZE; i++)
  {
    g_q_predictor.models[dist_min_idx][i] = learning_rate*g_q_predictor.models[dist_min_idx][i] +
                                            (1.0 - learning_rate)*g_q_predictor.input[i];
  }


  /*
    system state is know now, so process Q learning
  */
  float alpha = 0.7;  /*learning low pass filter constant <0, 1>, process is stochastic*/
  float gamma = 0.3;  /*discount factor <0, 1> */

  g_q_predictor.prev_state = g_q_predictor.state;
  g_q_predictor.state = dist_min_idx;

  float prev_q_value = g_q_predictor.q[g_q_predictor.state];

  g_q_predictor.q[g_q_predictor.state] =
    alpha*g_q_predictor.q[g_q_predictor.state] +
    (1.0 - alpha)*(gamma*g_q_predictor.q[g_q_predictor.prev_state] + reward);


  /*
    all states have Q(s) calculated now,
    use Q(s) to calculate output
  */
  float k = 0.03;
  g_q_predictor.output[g_q_predictor.state]+= k*(g_q_predictor.q[g_q_predictor.state]- prev_q_value);

  g_q_predictor.output[g_q_predictor.state] = m_saturate(0.5, 1.0, g_q_predictor.output[g_q_predictor.state]);

  return g_q_predictor.output[g_q_predictor.state];
}


void q_predictor_print()
{
  u32 i, j;

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
  {
    for (i = 0; i < Q_PREDICTOR_MODEL_SIZE; i++)
    {
      i32 value = g_q_predictor.models[j][i]*1000;
      printf_("%i ", value);
    }

    printf_("\n");
  }

  printf_("\n");

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
  {
    i32 value_output = g_q_predictor.output[j]*1000;
    printf_("%i ", value_output);
  }
  printf_("\n");

  for (j = 0; j < Q_PREDICTOR_MODELS_COUNT; j++)
  {
    i32 value_q = g_q_predictor.q[j]*1000;
    printf_("%i ", value_q);
  }
  printf_("\n");
  printf_("\n");
}
